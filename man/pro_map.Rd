% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/progressively.R
\name{pro_map}
\alias{pro_map}
\alias{pro_map2}
\alias{pro_pmap}
\alias{pro_map_if}
\alias{pro_map_at}
\alias{pro_map_chr}
\alias{pro_map_dbl}
\alias{pro_map_df}
\alias{pro_map_dfc}
\alias{pro_map_dfr}
\alias{pro_map_int}
\alias{pro_map_lgl}
\alias{pro_walk}
\alias{pro_map2_chr}
\alias{pro_map2_dbl}
\alias{pro_map2_df}
\alias{pro_map2_dfc}
\alias{pro_map2_dfr}
\alias{pro_map2_int}
\alias{pro_map2_lgl}
\alias{pro_walk2}
\alias{pro_imap}
\alias{pro_imap_chr}
\alias{pro_imap_dbl}
\alias{pro_imap_dfc}
\alias{pro_imap_dfr}
\alias{pro_imap_int}
\alias{pro_imap_lgl}
\alias{pro_iwalk}
\alias{pro_invoke_map}
\alias{pro_invoke_map_chr}
\alias{pro_invoke_map_dbl}
\alias{pro_invoke_map_df}
\alias{pro_invoke_map_dfc}
\alias{pro_invoke_map_dfr}
\alias{pro_invoke_map_int}
\alias{pro_invoke_map_lgl}
\alias{pro_lmap}
\alias{pro_lmap_at}
\alias{pro_lmap_if}
\alias{pro_modify}
\alias{pro_pmap_chr}
\alias{pro_pmap_dbl}
\alias{pro_pmap_df}
\alias{pro_pmap_dfc}
\alias{pro_pmap_dfr}
\alias{pro_pmap_int}
\alias{pro_pmap_lgl}
\alias{pro_pwalk}
\alias{pro_reduce}
\alias{pro_reduce_right}
\alias{pro_reduce2}
\alias{pro_reduce2_right}
\alias{pro_every}
\alias{pro_some}
\alias{pro_accumulate}
\alias{pro_accumulate_right}
\title{Modified purrr functions with progress bar}
\usage{
pro_map(.x, .f, ...)

pro_map2(.x, .y, .f, ...)

pro_pmap(.l, .f, ...)

pro_map_if(.x, .p, .f, ...)

pro_map_at(.x, .at, .f, ...)

pro_map(.x, .f, ...)

pro_map_at(.x, .at, .f, ...)

pro_map_chr(.x, .f, ...)

pro_map_dbl(.x, .f, ...)

pro_map_df(.x, .f, ..., .id = NULL)

pro_map_dfc(.x, .f, ...)

pro_map_dfr(.x, .f, ..., .id = NULL)

pro_map_if(.x, .p, .f, ...)

pro_map_int(.x, .f, ...)

pro_map_lgl(.x, .f, ...)

pro_walk(.x, .f, ...)

pro_map2(.x, .y, .f, ...)

pro_map2_chr(.x, .y, .f, ...)

pro_map2_dbl(.x, .y, .f, ...)

pro_map2_df(.x, .y, .f, ..., .id = NULL)

pro_map2_dfc(.x, .y, .f, ...)

pro_map2_dfr(.x, .y, .f, ..., .id = NULL)

pro_map2_int(.x, .y, .f, ...)

pro_map2_lgl(.x, .y, .f, ...)

pro_walk2(.x, .y, .f, ...)

pro_imap(.x, .f, ...)

pro_imap_chr(.x, .f, ...)

pro_imap_dbl(.x, .f, ...)

pro_imap_dfc(.x, .f, ..., .id = NULL)

pro_imap_dfr(.x, .f, ..., .id = NULL)

pro_imap_int(.x, .f, ...)

pro_imap_lgl(.x, .f, ...)

pro_iwalk(.x, .f, ...)

pro_invoke_map(.f, .x = list(NULL), ..., .env = NULL)

pro_invoke_map_chr(.f, .x = list(NULL), ..., .env = NULL)

pro_invoke_map_dbl(.f, .x = list(NULL), ..., .env = NULL)

pro_invoke_map_df(.f, .x = list(NULL), ..., .env = NULL)

pro_invoke_map_dfc(.f, .x = list(NULL), ..., .env = NULL)

pro_invoke_map_dfr(.f, .x = list(NULL), ..., .env = NULL)

pro_invoke_map_int(.f, .x = list(NULL), ..., .env = NULL)

pro_invoke_map_lgl(.f, .x = list(NULL), ..., .env = NULL)

pro_lmap(.x, .f, ...)

pro_lmap_at(.x, .at, .f, ...)

pro_lmap_if(.x, .p, .f, ...)

pro_modify(.x, .f, ...)

pro_pmap(.l, .f, ...)

pro_pmap_chr(.l, .f, ...)

pro_pmap_dbl(.l, .f, ...)

pro_pmap_df(.l, .f, ..., .id = NULL)

pro_pmap_dfc(.l, .f, ...)

pro_pmap_dfr(.l, .f, ..., .id = NULL)

pro_pmap_int(.l, .f, ...)

pro_pmap_lgl(.l, .f, ...)

pro_pwalk(.l, .f, ...)

pro_reduce(.x, .f, ..., .init)

pro_reduce_right(.x, .f, ..., .init)

pro_reduce2(.x, .y, .f, ..., .init)

pro_reduce2_right(.x, .y, .f, ..., .init)

pro_every(.x, .p, ...)

pro_some(.x, .p, ...)

pro_accumulate(.x, .f, ..., .init)

pro_accumulate_right(.x, .f, ..., .init)
}
\arguments{
\item{.x}{A list or atomic vector.}

\item{.f}{A function, formula, or atomic vector.

If a \strong{function}, it is used as is.

If a \strong{formula}, e.g. \code{~ .x + 2}, it is converted to a function. There
are three ways to refer to the arguments:
\itemize{
\item For a single argument function, use \code{.}
\item For a two argument function, use \code{.x} and \code{.y}
\item For more arguments, use \code{..1}, \code{..2}, \code{..3} etc
}

This syntax allows you to create very compact anonymous functions.

If \strong{character vector}, \strong{numeric vector}, or \strong{list}, it
is converted to an extractor function. Character vectors index by name
and numeric vectors index by position; use a list to index by position
and name at different levels. Within a list, wrap strings in \code{\link[=get-attr]{get-attr()}}
to extract named attributes. If a component is not present, the value of
\code{.default} will be returned.}

\item{...}{Additional arguments passed on to \code{.f}.}

\item{.p}{A single predicate function, a formula describing such a
predicate function, or a logical vector of the same length as \code{.x}.
Alternatively, if the elements of \code{.x} are themselves lists of
objects, a string indicating the name of a logical element in the
inner lists. Only those elements where \code{.p} evaluates to
\code{TRUE} will be modified.}

\item{.at}{A character vector of names or a numeric vector of
positions. Only those elements corresponding to \code{.at} will be
modified.}

\item{.id}{If not \code{NULL} a variable with this name will be created
giving either the name or the index of the data frame.}
}
\description{
Modified purrr functions with progress bar
}
